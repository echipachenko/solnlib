# Copyright 2016 Splunk, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"): you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

'''
log utility for Splunk solutions.
'''

import logging
import logging.handlers as handlers
import os.path as op

from splunksolutionlib.platform.platform import make_splunkhome_path
from splunksolutionlib.common.pattern import Singleton
import splunksolutionlib.common.utils as cutils


def log_enter_exit(logger):
    '''Decorator for logger to log function enter and exit.

    This decorator will generate a lot of debug log, please add this
    only when it is required.

    :param logger: logger to decorate

    Usage::
      >>> @log_enter_exit
      >>> def myfunc():
      >>>     doSomething()
    '''

    def log_decorator(func):
        def wrapper(*args, **kwargs):
            logger.debug('%s entered', func.__name__)
            result = func(*args, **kwargs)
            logger.debug('%s exited', func.__name__)
            return result

        return wrapper

    return log_decorator


class Logs(object):
    '''A singleton class that manage all kinds of logger.

    All loggers created by this singleton class with different name
    and all the log file will be written to $SPLUNK_HOME/var/log/splunk/.

    :param namespace: (optional) Logger namespace, default value is None
    :param default_level: (optional) Default logging level, default value
        is logging.INFO

    Usage::

      >>> from splunksolutionlib.common import log
      >>> logger = log.Logs(namespace='myapp').get_logger('mymodule')
      >>> Logs.set_level(logging.DEBUG)
      >>> logger.debug('a debug log')
    '''

    __metaclass__ = Singleton

    def __init__(self, namespace=None, default_level=logging.INFO):
        self._loggers = {}
        self._default_level = default_level
        if namespace is None:
            namespace = cutils.get_appname_from_path(op.abspath(__file__))

        if namespace:
            namespace = namespace.lower()
        self._namespace = namespace

    def get_logger(self, name, level=None, max_bytes=25000000, backup_count=5):
        ''' Get logger with the name of `name`.

        If logger with the name of `name` exists just return else create a new
        logger with the name of `name`.

        :param name: Log name, it will be used as log file name too
        :param level: The logging level
        :param max_bytes: (optional) The maximum log file size before rollover
        :param backup_count: (optional) The number of log files to retain
        :returns: Instance of logging.Logger
        :rtype: logging.Logger
        '''

        # Strip '.py' from the log file name if auto-generated by a script.
        if level is None:
            level = self._default_level

        name = self._get_log_name(name)
        if name in self._loggers:
            return self._loggers[name]

        logfile = make_splunkhome_path(['var', 'log', 'splunk', name])
        logger = logging.getLogger(name)

        handler_exists = any(
            [True for h in logger.handlers if h.baseFilename == logfile])
        if not handler_exists:
            file_handler = handlers.RotatingFileHandler(
                logfile,
                mode='a',
                maxBytes=max_bytes,
                backupCount=backup_count)
            formatter = logging.Formatter(
                '%(asctime)s %(levelname)s pid=%(process)d tid=%(threadName)s '
                'file=%(filename)s:%(funcName)s:%(lineno)d | %(message)s')
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)
            logger.setLevel(level)
            logger.propagate = False

        self._loggers[name] = logger
        return logger

    def set_level(self, level, name=None):
        '''Set log level of logger.

        Set log level of all logger if `name` is None else of
        logger with the name of `name`.

        :param level: Log level to set.
        :param name: (optional) The name of logger
        '''

        if name is not None:
            name = self._get_log_name(name)
            logger = self._loggers.get(name)
            if logger is not None:
                logger.setLevel(level)
        else:
            self._default_level = level
            for logger in self._loggers.itervalues():
                logger.setLevel(level)

    def _get_log_name(self, name):
        if name.endswith('.py'):
            name = name.replace('.py', '')

        if self._namespace:
            name = '{}_{}.log'.format(self._namespace, name)
        else:
            name = '{}.log'.format(name)
        return name
